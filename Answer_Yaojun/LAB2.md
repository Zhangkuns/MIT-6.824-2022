# 实验2：Raft（WIP）
- 这是一系列实验中的第一个，你将在其中构建一个容错的键值存储系统。在这个实验中，你将实现 Raft，一个复制状态机协议。在下一个实验中，你将在Raft之上构建一个键值服务。然后，你将把你的服务分片到多个复制状态机上，以实现更高的性能。
- 一项服务调用`Make(peers, me, ...)`来创建一个Raft对等节点。`peers`参数是一个包含 Raft 对等节点的网络标识符数组（包括当前节点），用于 RPC 通信。me参数是该对等节点在peers数组中的索引。Start(command)用于请求Raft开始处理将命令附加到复制日志中。`Start()`应该立即返回，而不等待日志附加操作完成。该服务期望您的实现为每个新提交的日志条目发送一个ApplyMsg到Make()函数中的applyCh通道参数。


- `raft.go`包含了发送RPC（`sendRequestVote()`）和处理传入RPC（`RequestVote()`）的示例代码。您的 Raft 对等节点应该使用`labrpc` Go包（源代码在`src/labrpc`中）进行 RPC 交换。测试程序可以通过l`abrpc`模拟各种网络故障，如延迟、重排序和丢弃 RPC 。虽然您可以暂时修改`labrpc`，但请确保您的Raft实现与原始的`labrpc`一起工作，因为我们将使用它来测试和评分您的实验。您的Raft实例只能通过 RPC 进行交互；例如，不允许使用共享的 Go 变量或文件进行通信。

- 后续的实验建立在这个实验的基础上，因此给自己足够的时间来编写稳定的代码非常重要。

## 2A 部分: 领导者选举 (中等)
- 实现Raft的领导者选举和心跳（不包含日志条目的`AppendEntries RPC`）。Part 2A的目标是选举出一个单一的领导者，并在没有故障的情况下保持领导者的地位，如果旧的领导者发生故障或者与旧的领导者之间的数据包丢失，则新的领导者接管。运行go test -run 2A来测试您的2A代码。
- 在`raft.go`中的Raft结构体中添加Figure 2中关于领导者选举的状态。您还需要定义一个结构体来保存每个日志条目的信息。
- 填写RequestVoteArgs和RequestVoteReply结构体。修改Make()函数以创建一个后台goroutine，定期发送RequestVote RPC，以便在一段时间内没有收到其他对等方的消息时启动领导者选举。通过这种方式，对等方将了解当前的领导者是谁，如果已经有领导者存在，或者成为新的领导者。实现`RequestVote() RPC`处理程序，使服务器可以互相投票。
- 为了实现心跳机制，定义一个`AppendEntries RPC`结构体（尽管你现在可能不需要所有的参数），并让领导者定期发送它们。编写一个`AppendEntries RPC`处理方法，用于重置选举超时，以防止其他服务器在已经选出领导者时步入其位置。
- 在旧领导者失败后的五秒内（如果大多数对等方仍然可以通信），测试程序要求你的Raft选举出新的领导者。然而，请记住，如果出现投票分裂（可能是因为数据包丢失或候选人不幸选择了相同的随机退避时间），领导者选举可能需要多轮。你必须选择足够短的选举超时时间（因此也是心跳间隔），以确保即使需要多轮，选举很有可能在五秒钟内完成。
- 论文的第5.2节提到选举超时应在150到300毫秒的范围内。这样的范围只有在领导者发送心跳的频率远远超过每150毫秒一次时才有意义。由于测试程序限制你每秒只能发送10个心跳，所以你将不得不使用比论文中的150到300毫秒更长的选举超时时间，但也不能太长，因为否则你可能无法在五秒内选举出一个领导者。
- 您可能会发现 Go 的`rand`很有用。
- 你需要编写定期或延时执行操作的代码。最简单的方法是创建一个带有循环的`goroutine`，其中调用`time.Sleep()`；（请参见Make()为此目的创建的`ticker() goroutine`）。不要使用Go的`time`.`Timer`或`time.Ticker`，它们很难正确使用。

- 指南页面提供了一些有关如何开发和调试代码的提示。
- 如果您的代码无法通过测试，请再次阅读本文的图 2； 领导者选举的完整逻辑分布在图中的多个部分。
- 不要忘记实现`GetState()`。
- 当测试程序永久关闭一个实例时，它会调用你的 Raft 的`rf.Kill()`方法。你可以使用`rf.killed()`方法检查是否已经调用了`Kill()`方法。你可能希望在所有的循环中都进行这个检查，以避免已关闭的Raft实例打印出令人困惑的消息。

- Go RPC仅发送以大写字母开头的结构体字段。子结构体也必须具有大写字母开头的字段名（例如，数组中的日志记录字段）。`labgob`包将会对此发出警告；不要忽略这些警告。

- 请确保在提交第 2A 部分之前通过 2A 测试，以便您看到如下内容：

```sh
$ go test -run 2A
Test (2A): initial election ...
  ... Passed --   3.5  3   58   16840    0
Test (2A): election after network failure ...
  ... Passed --   5.4  3  118   25269    0
Test (2A): multiple elections ...
  ... Passed --   7.3  7  624  138014    0
PASS
ok          6.824/raft        16.265s
$
```

- 每个"Passed"行包含五个数字；它们分别是测试所花费的时间（以秒为单位）、Raft对等方的数量、测试期间发送的RPC数量、RPC消息中的总字节数，以及Raft报告已提交的日志条目数量。你的数字可能与此处显示的数字不同。如果你愿意，你可以忽略这些数字，但它们可以帮助你对你的实现发送的RPC数量进行合理性检查。对于实验2、3和4，如果所有的测试（go test）花费的时间超过600秒，或者任何单个测试花费的时间超过120秒，评分脚本将失败你的解决方案。

- 在我们评估你的提交时，我们将在没有-race标志的情况下运行测试，但你也应确保你的代码在使用-race标志时始终能够通过测试。

## 2B 部分: 日志（困难）
- 实现领导者（leader）和跟随者（follower）的代码来追加新的日志条目，以使 go test -run 2B 测试通过。
- 运行git pull以获取最新的实验。
- 您的第一个目标应该是通过TestBasicAgree2B()。首先实现Start()，然后编写代码通过AppendEntries RPCs发送和接收新的日志条目，如下图2所示。在每个对等方的applyCh上发送每个新提交的条目。
- 你需要实现选举限制（论文 5.4.1 节）。
- 在早期的 Lab 2B 测试中，导致无法达成一致的一种方式是尽管领导者仍然存活，但持续进行选举。请检查选举定时器管理方面的错误，或者在赢得选举后没有立即发送心跳信号的问题。
- 你的代码可能包含循环，用于重复检查某些事件。请不要让这些循环无间断地执行，因为这会使你的实现变慢以至于无法通过测试。你可以使用 Go 语言的条件变量（condition variables），或者在每次循环迭代中插入 time.Sleep(10 * time.Millisecond) 的延迟。
- 为了以后的实验，为自己做个好处，编写（或重新编写）干净、清晰的代码。如果需要灵感，可以重新访问我们提供的指导页面，其中包含有关如何开发和调试代码的提示。
- 如果你的测试失败了，可以查看 config.go 和 test_test.go 中的测试代码，以更好地理解测试的目的。config.go 还展示了测试器如何使用 Raft API。
如果你的代码运行过慢，那么即将到来的实验中的测试可能会导致测试失败。你可以使用 time 命令来检查你的解决方案使用了多少实际时间和 CPU 时间。下面是一个典型的输出示例：

```sh
$ time go test -run 2B
Test (2B): basic agreement ...
  ... Passed --   0.9  3   16    4572    3
Test (2B): RPC byte count ...
  ... Passed --   1.7  3   48  114536   11
Test (2B): agreement after follower reconnects ...
  ... Passed --   3.6  3   78   22131    7
Test (2B): no agreement if too many followers disconnect ...
  ... Passed --   3.8  5  172   40935    3
Test (2B): concurrent Start()s ...
  ... Passed --   1.1  3   24    7379    6
Test (2B): rejoin of partitioned leader ...
  ... Passed --   5.1  3  152   37021    4
Test (2B): leader backs up quickly over incorrect follower logs ...
  ... Passed --  17.2  5 2080 1587388  102
Test (2B): RPC counts aren't too high ...
  ... Passed --   2.2  3   60   20119   12
PASS
ok          6.824/raft        35.557s

real        0m35.899s
user        0m2.556s
sys        0m1.458s
$
```

- "ok 6.824/raft 35.557s" 的意思是 Go 语言测量了完成 2B 测试所花费的实际时间为 35.557 秒。"user 0m2.556s" 表示代码消耗了 2.556 秒的 CPU 时间，即实际执行指令的时间（而不是等待或休眠的时间）。如果你的解决方案在完成 2B 测试时使用了超过一分钟的实际时间，或者超过 5 秒的 CPU 时间，可能会遇到问题。请查找花费在休眠或等待 RPC 超时上的时间、没有休眠或等待条件或通道消息的循环，或者发送大量 RPC 的情况。

## 2C 部分：持久化（困难）
- 如果基于 Raft 的服务器重新启动，它应该能恢复退出时的服务。这需要 Raft 保持持久状态以在重新启动后正常运行。论文的图 2 提到了应该持久的状态。

- 一个真实的实现会在每次更改 Raft 的持久状态时将其写入磁盘，并在重新启动后从磁盘读取状态。您的实现将不使用磁盘；相反，它将从 Persister 对象（参见`persister.go`）保存和恢复持久状态。调用`Raft.Make()`的人提供一个最初保存 Raft 最近持久状态的 Persister（如果有的话）。 Raft 应该从该Persister初始化其状态，并且每次状态更改时都应该使用它保存其持久状态。使用 Persister 的`ReadRaftState()`和`SaveRaftState()`方法。

- 请在`raft.go`中的`persist()`和`readPersist()`函数中添加代码来保存和恢复持久状态。你需要将状态编码（或“序列化”）为字节数组，以便将其传递给Persister。使用`labgob`编码器；请参阅`persist()`和`readPersist()`中的注释。labgob类似于Go的gob编码器，但如果你尝试对具有小写字段名的结构进行编码，则会打印错误消息。在更改持久状态的实现点插入`persist()`的调用。完成这些步骤后，如果你的其余实现正确，您应该通过所有 2C 测试。

- 运行`git pull` 获取最新的实验代码。
- 2C 测试比 2A 或 2B 测试要求更高，而且失败可能是由于你在 2A 或 2B 代码中的问题导致的。
- 你可能需要对`nextIndex`进行优化，一次备份多个条目。请查看扩展 Raft 论文，从第7页底部和第8页顶部开始（由一条灰色线标记）。论文对细节描述比较模糊，你需要填补这些空白，可能需要借助6.824 Raft讲义的帮助。
- 你的代码应该通过所有 2C 测试（如下所示）以及 2A 和 2B 测试。
```sh
$ go test -run 2C
Test (2C): basic persistence ...
  ... Passed --   5.0  3   86   22849    6
Test (2C): more persistence ...
  ... Passed --  17.6  5  952  218854   16
Test (2C): partitioned leader and one follower crash, leader restarts ...
  ... Passed --   2.0  3   34    8937    4
Test (2C): Figure 8 ...
  ... Passed --  31.2  5  580  130675   32
Test (2C): unreliable agreement ...
  ... Passed --   1.7  5 1044  366392  246
Test (2C): Figure 8 (unreliable) ...
  ... Passed --  33.6  5 10700 33695245  308
Test (2C): churn ...
  ... Passed --  16.1  5 8864 44771259 1544
Test (2C): unreliable churn ...
  ... Passed --  16.5  5 4220 6414632  906
PASS
ok          6.824/raft        123.564s
$
```
- 最好在提交之前多次运行测试并检查每次运行是否打印PASS。
```shell
$ for i in {0..10}; do go test; done
```
## 2D 部分：日志压缩（困难）
- 目前情况下，重新启动的服务器会重新回放完整的 Raft 日志以恢复其状态。然而，对于长时间运行的服务来说，永远记住完整的 Raft 日志是不实际的。相反，您将修改 Raft 以与定期存储其状态的服务进行协作，这些服务在某些时候持久地存储其状态快照，此时 Raft 会丢弃在快照之前的日志条目。这样可以减少持久化数据的量，并实现更快的重启。然而，现在可能发生的情况是，一个跟随者落后太多，以至于领导者已经丢弃了它需要追赶的日志条目；此时，领导者必须发送一个快照以及从快照时刻开始的日志。扩展 Raft 论文的第7节概述了这个方案；您需要设计具体细节。

- 您可能会发现参考 Raft 交互图有助于理解复制服务和 Raft 之间的通信方式。

- 您的 Raft 必须提供以下函数，服务可以调用该函数并提供其状态的序列化快照：
```go
Snapshot(index int, snapshot []byte)
```

- 在实验2D中，测试程序会定期调用`Snapshot()`函数。在实验3中，您将编写一个`key/value`服务器，该服务器会调用`Snapshot()`函数；快照将包含完整的键值对表。服务层在每个节点（而不仅仅是领导者）上调用`Snapshot()`函数。


- 索引参数指示在快照中反映的最高日志条目。Raft 应该在该点之前丢弃其日志条目。您需要修改 Raft 代码，仅保存日志的末尾。

- 您需要实现论文中讨论的`InstallSnapshot RPC`，该 RPC 允许Raft 领导者告知落后的 Raft 节点使用快照替换其状态。您可能需要仔细思考`InstallSnapshot`应该如何与图2中的状态和规则进行交互。


- 当一个跟随者的 Raft 代码接收到`InstallSnapshot RPC`时，它可以使用`applyCh`将快照作为`ApplyMsg`发送给服务。`ApplyMsg`结构体定义已经包含了您所需的字段（也是测试程序所期望的）。请注意，这些快照只会推进服务的状态，不会导致其向后移动。


- 如果服务器崩溃，它必须从持久化数据重新启动。您的 Raft 应该持久化 Raft 状态和相应的快照。使用`persister.SaveStateAndSnapshot()`函数，它接受 Raft 状态和相应快照的单独参数。如果没有快照，将快照参数传递为`nil`。

- 当服务器重新启动时，应用层读取持久化的快照并恢复其保存的状态。

- 先前，在这个实验中建议您实现一个名为`CondInstallSnapshot`的函数，以避免在`applyCh`上发送的快照和日志条目需要协调的要求。这个过时的API接口仍然存在，但不建议您实现它：相反，我们建议您只需让它返回`true`即可


- 请实现`Snapshot()`函数、`InstallSnapshot RPC`以及支持这些功能的Raft的更改（例如，与修剪日志一起操作）。当您的解决方案通过2D测试（以及所有之前的Lab 2测试）时，即表示完成。
- 一个好的起点是修改您的代码，使其能够仅存储从某个索引X开始的日志部分。最初，您可以将X设置为零并运行2B/2C测试。然后，使`Snapshot(index)`函数丢弃索引之前的日志，并将X设置为`index`。如果一切顺利，您现在应该通过第一个2D测试。
- 您将无法将日志存储在 Go 切片中，并可在 Raft 日志索引和 Go 切片索引之间互换使用；您需要以一种考虑到已丢弃日志部分的方式对切片进行索引。
- 下一步：如果领导者没有所需的日志条目来使跟随者保持最新状态，则让领导者发送`InstallSnapshot RPC`。
- 在单个`InstallSnapshot RPC`中发送整个快照。不要实现图13中用于拆分快照的偏移机制。
- Raft 必须以使 Go 垃圾回收器能够释放和重用内存的方式丢弃旧的日志条目；这要求被丢弃的日志条目没有可达的引用（指针）。
- 即使日志被修剪，您的实现仍然需要正确地在`AppendEntries RPC`中发送前一个条目的任期和索引；这可能需要保存并引用最新快照的`lastIncludedTerm/lastIncludedIndex`（请考虑是否应该持久化）。
- 在没有`-race`选项的情况下，完成所有Lab 2测试（2A+2B+2C+2D）的合理时间是实际时间的6分钟和 CPU 时间的1分钟。在使用`-race`选项运行时，大约需要实际时间的10分钟和 CPU 时间的2分钟。

- 您的代码应通过所有 2D 测试（如下所示）以及 2A、2B 和 2C 测试。
```sh
$ go test -run 2D
Test (2D): snapshots basic ...
  ... Passed --  11.6  3  176   61716  192
Test (2D): install snapshots (disconnect) ...
  ... Passed --  64.2  3  878  320610  336
Test (2D): install snapshots (disconnect+unreliable) ...
  ... Passed --  81.1  3 1059  375850  341
Test (2D): install snapshots (crash) ...
  ... Passed --  53.5  3  601  256638  339
Test (2D): install snapshots (unreliable+crash) ...
  ... Passed --  63.5  3  687  288294  336
Test (2D): crash and restart all servers ...
  ... Passed --  19.5  3  268   81352   58
PASS
ok      6.824/raft      293.456s
```
- 再次提醒您，当我们对您提交的内容进行评分时，我们将运行不带 `-race` 标志的测试，但您还应该确保您的代码始终通过带 `-race` 标志的测试。